

在你视图的任何位置, 临时插入一个 assert False 来触发出错页. 然后, 你就可以看到
局部变量和程序语句了.



4.  Django模板系统

4.1 启动交互界面

// 启动交互界面
$ python manage.py shell


// 下面是一些基本操作:
>>> from django.template import Template
>>> t = Template("My name is {{ name }}.")
>>> print t


// 如果你的模板语法有错误, 那么在调用 Template() 时就会抛出
// TemplateSyntaxError 异常:
>>> from django.template import Template
>>> t = Template('{% notatag %} ')
Traceback (most recent call last):
File "<stdin>", line 1, in ?
...
django.template.TemplateSyntaxError: Invalid block tag: 'notatag'


4.2 调用 Template 对象的 render() 方法并传递context来填充模板:

// 调用 Template 对象的 render() 方法并传递context来填充模板:
>>> from django.template import Context, Template
>>> t = Template("My name is {{ name }}.")
>>> c = Context({"name": "Stephane"})
>>> t.render(c)
'My name is Stephane.'


4.3 字典和Contexts

// 字典和Contexts
// 下面是编写模板并渲染的示例:
>>> from django.template import Template, Context
>>> raw_template = """<p>Dear {{ person_name }},</p>
... <p>Thanks for ordering {{ product }} from {{ company }}. It's scheduled
... to ship on {{ ship_date|date:"F j, Y" }}.</p>
... {% if ordered_warranty %}
... <p>Your warranty information will be included in the packaging.</p>
... {% endif %}
... <p>Sincerely,<br />{{ company }}</p>"""
>>> t = Template(raw_template)
>>> import datetime
>>> c = Context({'person_name': 'John Smith',
... 'product': 'Super Lawn Mower',
... 'company': 'Outdoor Equipment',
... 'ship_date': datetime.date(2009, 4, 2),
... 'ordered_warranty': True})
>>> t.render(c)
"<p>Dear John Smith,</p>\n\n<p>Thanks for ordering Super Lawn Mower from
Outdoor Equipment. It's scheduled \nto ship on April 2, 2009.</p>\n\n\n
<p>Your warranty information will be included in the packaging.</p>\n\n\n
<p>Sincerely,<br />Outdoor Equipment</p>"
>>> print t.render(c)


# 这就是使用Django模板系统的基本规则: 写模板, 创建 Template 对象, 创建
# Context ,  调用 render() 方法.


4.4 同一模板 多个上下文

// 同一模板, 多个上下文
// 一旦有了 模板 对象, 你就可以通过它渲染多个背景(context), 例如:
>>> from django.template import Template, Context
>>> t = Template('Hello, {{ name }}')
>>> print t.render(Context({'name': 'John'}))
Hello, John
>>> print t.render(Context({'name': 'Julie'}))
Hello, Julie
>>> print t.render(Context({'name': 'Pat'}))
Hello, Pat


// 无论何时像这样使用同一模板源渲染多个背景, 只创建 一次 模板 对象, 然后对它多
// 次调用 render() 将会更加高效.
# Bad
>>> for name in ('John', 'Julie', 'Pat'):
>>>     t = Template('Hello, {{ name }}')
>>>     print t.render(Context({'name': name}))
>>>
# Good
>>> t = Template('Hello, {{ name }}')
>>> for name in ('John', 'Julie', 'Pat'):
>>>     print t.render(Context({'name': name}))
>>>


4.5 使用句点可以访问字典的键值 属性 索引 对象的方法

// 在 Django 模板中遍历复杂数据结构的关键是句点字符 (.). 使用句点可以访问字典
// 的键值,属性,索引和对象的方法.
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
'Sally is 43 years old.'


// 同样, 也可以通过句点来访问对象的属性. 比方说,  Python 的 datetime.date 对象
// 有 year , month 和 day 几个属性,
>>> from django.template import Template, Context
>>> import datetime
>>> d = datetime.date(1993, 5, 2)
>>> d.year
1993
>>> d.month
5
>>> d.day
2
>>> t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')
>>> c = Context({'date': d})
>>> t.render(c)
'The month is 5 and the year is 1993.'


4.5.1 用了一个自定义类:

// 下例使用了一个自定义类:
>>> from django.template import Template, Context
>>> class Person(object):
...     def __init__(self, first_name, last_name):
...         self.first_name, self.last_name = first_name, last_name
...
>>> t = Template('Hello, {{ person.first_name }} {{ person.last_name }}.')
>>> c = Context({'person': Person('John', 'Smith')})
>>> t.render(c)
'Hello, John Smith.'


4.5.2 句点还用于调用对象的方法

// 句点还用于调用对象的方法. 例如, 每个 Python 字符串都有 upper() 和 isdigit()
// 方法, 你在模板中可以使用同样的句点语法来调用它们:
// 注意: 你不能在方法调用中使用圆括号. 而且也无法给该方法传递参数; 你只能调用
//       不需参数的方法.
>>> from django.template import Template, Context
>>> t = Template('{{ var }} -- {{ var.upper }} -- {{ var.isdigit }}')
>>> t.render(Context({'var': 'hello'}))
'hello -- HELLO -- False'
>>> t.render(Context({'var': '123'}))
'123 -- 123 -- True'


4.5.3 句点也可用于访问列表索引

// 句点也可用于访问列表索引, 例如:
// 注意: 不允许使用负数列表索引. 像 {{ items.-1 }} 这样的模板变量将会引发
//       TemplateSyntaxError 异常.
>>> from django.template import Template, Context
>>> t = Template('Item 2 is {{ items.2 }}.')
>>> c = Context({'items': ['apples', 'bananas', 'carrots']})
>>> t.render(c)
'Item 2 is carrots.'


4.5.4 句点查找规则可概括为:

# 句点查找规则可概括为: 当模板系统在变量名中遇到点时,按照以下顺序尝试进行查找:
#   字典类型查找 (比如 foo["bar"] )
#   属性查找 (比如 foo.bar )
#   方法调用 (比如 foo.bar() )
#   列表类型索引查找 (比如 foo[bar] )
# 系统使用所找到的第一个有效类型. 这是一种短路逻辑.


4.5.5 句点查找可以多级深度嵌套

// 句点查找可以多级深度嵌套
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name.upper }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
'SALLY is 43 years old.'

4.5.6 方法调用行为

# 方法调用行为
// 方法调用比其他类型的查找略为复杂一点. 以下是一些注意事项:
// 在方法查找过程中, 如果某方法抛出一个异常, 除非该异常有一个
// silent_variable_failure属性并且值为 True , 否则的话它将被传播. 如果该异常
// 确有属性 silent_variable_failure , 那么(所查找)变量将被渲染为空字符串,
// 例如:
>>> t = Template("My name is {{ person.first_name }}.")
>>> class PersonClass3:
...     def first_name(self):
...         raise AssertionError, "foo"
...
>>> p = PersonClass3()
>>> t.render(Context({"person": p}))
Traceback (most recent call last):
...
AssertionError: foo

>>> class SilentAssertionError(AssertionError):
...     silent_variable_failure = True
...
>>> class PersonClass4:
...     def first_name(self):
...         raise SilentAssertionError
...
>>> p = PersonClass4()
>>> t.render(Context({"person": p}))
"My name is ."


// 不允许模板包含像 {{account.delete}} 这样的方法调用, 必须设置该方法的
// alters_data 函数属性:
// 模板系统不会执行任何以该方式进行标记的方法. 也就是说, 如果模板包含了
// {{account.delete}} ,该标签不会调用 delete() 方法. 它只会安静地失败(并不会
// 引发异常).
def delete(self):
    # Delete the account
    delete.alters_data = True


4.5.7 如何处理无效变量

# 如何处理无效变量
// 默认情况下, 如果一个变量不存在, 模板系统会把它展示为空字符串, 不做任何事情
// 地表示失败, 例如:
>>> from django.template import Template, Context
>>> t = Template('Your name is {{ name }}.')
>>> t.render(Context())
'Your name is .'
>>> t.render(Context({'var': 'hello'}))
'Your name is .'
>>> t.render(Context({'NAME': 'hello'}))
'Your name is .'
>>> t.render(Context({'Name': 'hello'}))
'Your name is .'


4.6 玩一玩上下文(context)对象

// 多数时间, 你可以通过传递一个完全填充(full populated)的字典给 Context() 来初
// 始化 上下文(Context) .  但是初始化以后, 你也可以从``上下文(Context)`` 对象
// 添加或者删除条目, 使用标准的Python字典语法(syntax):
>>> from django.template import Context
>>> c = Context({"foo": "bar"})
>>> c['foo']
'bar'
>>> del c['foo']
>>> c['foo']
''
>>> c['newvariable'] = 'hello'
>>> c['newvariable']
'hello'


4.7 标签

4.7.1 if/else

// {% else %} 标签是可选的:
{% if today_is_weekend %}
    <p>Welcome to the weekend!</p>
{% else %}
    <p>Get back to work.</p>
{% endif %}

4.7.1.1 Python 的"真值"

在python中空的列表 ( [] ), tuple( () ), 字典( {} ), 字符串( '' ), 零( 0 ), 还
有 None 对象, 在逻辑判断中都为假, 其他的情况都为真.

4.7.1.2 {% if %} 标签接受 and or 或者 not 关键字来对多个变量做判断 或者对变量取反( not )

{% if athlete_list and coach_list %}
    Both athletes and coaches are available.
{% endif %}
{% if not athlete_list %}
    There are no athletes.
{% endif %}
{% if athlete_list or coach_list %}
    There are some athletes or some coaches.
{% endif %}
{% if not athlete_list or coach_list %}
    There are no athletes or there are some coaches. (OK, so
    writing English translations of Boolean logic sounds
    stupid; it's not our fault.)
{% endif %}
{% if athlete_list and not coach_list %}
    There are some athletes and absolutely no coaches.
{% endif %}


4.7.1.3 {% if %} 标签不允许在同一个标签中同时使用 and 和 or

{% if %} 标签不允许在同一个标签中同时使用 and 和 or , 因为逻辑上可能模糊的, 例如, 如下示例是错误的:
{% if athlete_list and coach_list or cheerleader_list %} // 错误!!!!!


// 系统不支持用圆括号来组合比较操作. 如果你发现需要组合操作, 可以使用嵌套的
// {% if %} 标签
{% if athlete_list %}
    {% if coach_list or cheerleader_list %}
        We have athletes, and either coaches or cheerleaders!
    {% endif %}
{% endif %}

// 多次使用同一个逻辑操作符是没有问题的
{% if athlete_list or coach_list or parent_list or teacher_list %}

// 并没有 {% elif %} 标签, 请使用嵌套的 {% if %} 标签来达成同样的效果:
{% if athlete_list %}
    <p>Here are the athletes: {{ athlete_list }}.</p>
{% else %}
    <p>No athletes are available.</p>
    {% if coach_list %}
        <p>Here are the coaches: {{ coach_list }}.</p>
    {% endif %}
{% endif %}


4.7.2 for

// 例如, 给定一个运动员列表 athlete_list 变量, 我们可以使用下面的代码来显示这个列表:
<ul>
{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
{% endfor %}
</ul>

// 给标签增加一个 reversed 使得该列表被反向迭代:
{% for athlete in athlete_list reversed %}
    ...
{% endfor %}

// 可以嵌套使用 {% for %} 标签:
{% for country in countries %}
    <h1>{{ country.name }}</h1>
    <ul>
        {% for city in country.city_list %}
            <li>{{ city }}</li>
        {% endfor %}
    </ul>
{% endfor %}

4.7.2.1 {% for %} 标签在循环中的一个特殊的 forloop 模板变量

{% for %} 标签在循环中设置了一个特殊的 forloop 模板变量. 这个变量能提供一些当
前循环进展的信息:

1)  forloop.counter 总是一个表示当前循环的执行次数的整数计数器.
    这个计数器是从1开始的, 所以在第一次循环时 forloop.counter 将会被设置为1.

// 例子如下:
{% for item in todo_list %}
    <p>{{ forloop.counter }}: {{ item }}</p>
{% endfor %}

2)  forloop.counter0 类似于 forloop.counter , 但是它是从0计数的.
    第一次执行循环时这个变量会被设置为0.

3)  forloop.revcounter 是表示循环中剩余项的整型变量.
    在循环初次执行时 forloop.revcounter 将被设置为序列中项的总数. 最后一次循环
    执行中, 这个变量将被置1.

4)  forloop.revcounter0 类似于 forloop.revcounter , 但它以0做为结束索引.
    在第一次执行循环时, 该变量会被置为序列的项的个数减1. 在最后一次迭代时, 该
    变量为0.

5)  forloop.first 是一个布尔值. 在第一次执行循环时该变量为True, 在下面的情形中
    这个变量是很有用的.

{% for object in objects %}
    {% if forloop.first %}<li class="first">{% else %}<li>{% endif %}
    {{ object }}
    </li>
{% endfor %}

6)  forloop.last 是一个布尔值; 在最后一次执行循环时被置为True.
    一个常见的用法是在一系列的链接之间放置管道符(|)

{% for link in links %}{{ link }}{% if not forloop.last %} | {% endif %}{% endfor %}
    The above template code might output something like this::
    Link1 | Link2 | Link3 | Link4

7)  forloop.parentloop 是一个指向当前循环的上一级循环的 forloop 对象的引用(在嵌
    套循环的情况下).

// 例子在此:
{% for country in countries %}
    <table>
    {% for city in country.city_list %}
        <tr>
        <td>Country #{{ forloop.parentloop.counter }}</td>
        <td>City #{{ forloop.counter }}</td>
        <td>{{ city }}</td>
        </tr>
    {% endfor %}
    </table>
{% endfor %}


4.7.3 ifequal/ifnotequal

{% ifequal %} 标签比较两个值, 当他们相同时, 显示在 {% ifequal %} 和
{% endifequal %} 之中所有的值.

// 下面的例子比较两个模板变量 user 和 currentuser :
{% ifequal user currentuser %}
    <h1>Welcome!</h1>
{% endifequal %}

// 参数可以是硬编码的字符串, 随便用单引号或这双引号引起来, 所以下列代码都是正
// 确的:
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% endifequal %}
{% ifequal section "community" %}
    <h1>Community</h1>
{% endifequal %}

// 和 {% if %} 类似,  {% ifequal %} 支持可选的 {% else%} 标签:
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% else %}
    <h1>No News Here</h1>
{% endifequal %}

// 注意:    只有模板变量, 字符串, 整数和小数可以作为 {% ifequal %} 标签的参数.
//          其他的一些类型, 例如Python的字典类型,列表类型,布尔类型, 不能用在
//          {% ifequal %} 中.
//这些是正确的例子:
{% ifequal variable 1 %}
{% ifequal variable 1.23 %}
{% ifequal variable 'foo' %}
{% ifequal variable "foo" %}


4.8 注释

象HTML和其他的语言例如python一样, Django模板系统也允许注释.  注释使用 {# #} :

注释不能跨多行.

{# This is a comment #}


4.9 过滤器

1)  使用 | 来应用过滤器.

2)  过滤器可以被 串联 ,就是说一个过滤器的输出可以被输入到下一个过滤器.

// 这里有一个常用的 需求, 先转义文本到HTML, 再转换每行到 <p> 标签:
{{ my_text|escape|linebreaks }}

3)  过滤器参数总是使用双引号标识.

// 这个将显示变量 bio 的前30个词.
{{ bio|truncatewords:"30" }}


4.9.1 一些最重要的过滤器

1)  addslashes : 添加反斜杠到任何反斜杠,单引号或者双引号前面.
    这在处理包含JavaScript的文本时是非常有用的.

2)  date : 按指定的格式字符串参数格式化 date 或者 datetime 对象.

// 范例:
{{ pub_date|date:"F j, Y" }}

3)  escape : 转义 &符号, 引号, <, > 符号.

这在确保用户提交的数据是有效的XML或XHTML时是非常有用的.

具体上,  escape 做下面这些转换:
    转换 & 到 &amp;
    转换 < 到 &lt;
    转换 > 到 &gt;
    转换 " (双引号) 到 &quot;
    转换 ' (单引号) 到 &#39;

4)  length : 返回变量的长度.

你可以对列表或者字符串, 或者任何知道怎么测定长度的Python 对象使用这个方法(也就
是说, 有 __len__() 方法的对象).





5. 和数据库打交道: 数据建模

5.1 数据库配置

象前面章节提到的 TEMPLATE_DIRS 一样, 数据库配置也是在Django的配置文件里, 缺省
是 settings.py . 编辑打开这个文件并查找数据库配置:

DATABASE_ENGINE = ''
DATABASE_NAME = ''
DATABASE_USER = ''
DATABASE_PASSWORD = ''
DATABASE_HOST = ''
DATABASE_PORT = ''


DATABASE_ENGINE     告诉Django使用哪个数据库引擎. 如果你在 Django 中使用数据库,
DATABASE_ENGINE     必须是 Table 5-1 中所列出的值.
    表 5-1. 数据库引擎设置
    ...
DATABASE_NAME       将数据库名称告知 Django . 如果使用 SQLite, 请对数据库文件
                    指定完整的文件系统路径. (例如 '/home/django/mydata.db' ).
DATABASE_USER       告诉 Django 用哪个用户连接数据库. 如果用SQLite, 空白即可.
DATABASE_PASSWORD   告诉Django连接用户的密码. SQLite 用空密码即可.
DATABASE_HOST       告诉 Django 连接哪一台主机的数据库服务器. 如果数据库与
                    Django 安装于同一台计算机(即本机), 可将此项保留空白. 使用
                    SQLite , 也可保留空白.
                    此处的 MySQL 是一个特例. 如果使用的是 MySQL 且该项设置值由
                    斜杠( '/' )开头, MySQL 将通过 Unix socket 来连接指定的套接
                    字, 例如:
                        DATABASE_HOST = '/var/run/mysql'
                    如果用 MySQL 而该项设置的值 不是 以正斜线开始的, 系统将假
                    定该项值是主机名.
DATABASE_PORT       告诉 Django 连接数据库时使用哪个端口. 如果用SQLite, 空白即
                    可. 其他情况下, 如果将该项设置保留空白, 底层数据库适配器将
                    会连接所给定数据库服务器的缺省端口.


// 启动交互界面
$ python manage.py shell

// 输入下面这些命令来测试你的数据库配置:
>>> from django.db import connection
>>> cursor = connection.cursor()


5.2 你的第一个应用程序

须创建一个新的app.

// 转到 mysite 项目目录, 执行下面的命令来创建一个新app叫做books:
$ python manage.py startapp books


// 第一步是用Python代码来描述它们. 打开 models.py 并输入下面的内容:
from django.db import models

class Publisher(models.Model):
    name = models.CharField(maxlength=30)
    address = models.CharField(maxlength=50)
    city = models.CharField(maxlength=60)
    state_province = models.CharField(maxlength=30)
    country = models.CharField(maxlength=50)
    website = models.URLField()

class Author(models.Model):
    salutation = models.CharField(maxlength=10)
    first_name = models.CharField(maxlength=30)
    last_name = models.CharField(maxlength=40)
    email = models.EmailField()
    headshot = models.ImageField(upload_to='/tmp')

class Book(models.Model):
    title = models.CharField(maxlength=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()


编辑 settings.py 文件,  找到 INSTALLED_APPS 设置.  INSTALLED_APPS 告诉 Django
项目哪些 app 处于激活状态.


// 现在我们可以创建数据库表了. 首先, 用下面的命令对校验模型的有效性:
$ python manage.py validate


// 模型确认没问题了, 运行下面的命令来生成 CREATE TABLE 语句:
$ python manage.py sqlall books


// 执行这些SQL语句. 运行 syncdb 命令:
$ python manage.py syncdb


注意:   syncdb 并 不能 同步模型的修改到数据库. 如果你修改了模型, 然后你想更新 数
        据库, 是帮不了你的.


// 登录进数据库服务器看看刚才Django创建的数据表.  Django带有一个命令行工具,
$ python manage.py dbshell


5.3 基本数据访问

运行 python manage.py shell 并输入下面的内容试试看:

$ python manage.py shell

>>> from books.models import Publisher
>>> p1 = Publisher(name='Addison-Wesley', address='75 Arlington Street',
...  city='Boston', state_province='MA', country='U.S.A.',
...  website='http://www.apress.com/')
...
>>> p1.save()
>>> p2 = Publisher(name="O'Reilly", address='10 Fawcett St.',
...  city='Cambridge', state_province='MA', country='U.S.A.',
...  website='http://www.oreilly.com/')
...
>>> p2.save()
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Publisher object>, <Publisher: Publisher object>]


添加模块的字符串表现


>>> from books.models import Publisher
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Addison-Wesley>, <Publisher: O'Reilly>]


5.4 插入和更新数据

// 先使用一些关键参数创建对象实例, 如下:
>>> p = Publisher(name='Apress',
...  address='2755 Telegraph Ave.',
...  city='Berkeley',
...  state_province='CA',
...  country='U.S.A.',
...  website='http://www.apress.com/')
...
>>> p.save()

>>> p.id
 52  // this will differ based on your own data

// 接下来再调用 save() 将不会创建新的记录, 而只是修改记录内容(也就是 执行
// UPDATE SQL语句, 而不是 INSERT 语句):
>>> p.name = 'Apress Publishing'
>>> p.save()


5.5 选择对象

// 查找所有数据的方法:
>>> Publisher.objects.all()
[<Publisher: Addison-Wesley>, <Publisher: O'Reilly>, <Publisher: Apress Publishing>]


5.6 数据过滤

// 如果想要获得数据的一个子集, 我们可以使用 filter() 方法:
>>> Publisher.objects.filter(name="Apress Publishing")
[<Publisher: Apress Publishing>]

    filter() 根据关键字参数来转换成 WHERE SQL语句. 前面这个例子 相当于这样:
    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name = 'Apress Publishing';


// 可以传递多个参数到 filter() 来缩小选取范围:
>>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
[<Publisher: Apress Publishing>]

>>> Publisher.objects.filter(name__contains="press")
[<Publisher: Apress Publishing>]


5.7 获取单个对象

// 有时你只想获取单个对象, 这个时候使用 get() 方法:
>>> Publisher.objects.get(name="Apress Publishing")
<Publisher: Apress Publishing>

这样, 就返回了单个对象, 而不是列表(更准确的说, QuerySet).
所以, 如果结果是多个对象, 会导致抛出异常, 如果查询没有返回结果也会抛出异常.


5.8 数据排序

用 order_by() 来 排列返回的数据:

>>> Publisher.objects.order_by("name")
[<Publisher: Apress Publishing>, <Publisher: Addison-Wesley>, <Publisher: O'Reilly>]

>>> Publisher.objects.order_by("state_provice", "address")
[<Publisher: Apress Publishing>, <Publisher: O'Reilly>, <Publisher: Addison-Wesley>]

// 我们还可以指定逆向排序, 在前面加一个减号 - 前缀:
>>> Publisher.objects.order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

// 同时做 过滤和排序
>>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

// 只显示第一个. 你可以 这样做:
>>> Publisher.objects.all()[0]
<Publisher: Addison-Wesley>


5.9 删除对象

// 要删除对象, 只需简单的调用对象的 delete() 方法:
>>> p = Publisher.objects.get(name="Addison-Wesley")
>>> p.delete()
>>> Publisher.objects.all()
[<Publisher: Apress Publishing>, <Publisher: O'Reilly>]

// 还可以批量删除对象, 通过对查询的结果调用 delete() 方法:
>>> publishers = Publisher.objects.all()
>>> publishers.delete()
>>> Publisher.objects.all()
[]

注意:
    删除是 不可恢复 的, 所以要小心操作!事实上, 应该尽量避免删除对象, 除非你 确
    实需要删除它. 数据库的数据恢复的功能通常不太好, 而从备份数据恢复是很痛苦的


5.10 修改数据库表结构

当我们在这一章的前面介绍 syncdb 命令的时候, 我们强调 syncdb 仅仅创建数据库中不
存在的表, 而不会同步模型的修改或者删除到数据库. 如果你添加或者修改了模型的一个
字段, 或者删除一个模型, 你必须手动改变你的数据库.


当我们处理表结构的修改时, 要时刻想着 Django 的数据库层是如何工作的:
    1)  如果模型中包含一个在数据库中并不存在的字段, Django会大声抱怨的. 这样当你第
        一次调用Django的数据库API来查询给定的表时就会出错(也就是说, 它会在执行的时
        候出错, 而不是编译的时候)
    2)  Django并不关心数据库表中是否存在没有在模型中定义的列
    3)  Django并不关心数据库中是否包含没有模型描述的表


5.10.1 添加字段

ALTER TABLE books_book ADD COLUMN num_pages integer;

首先, 在开发环境中执行下面的步骤(也就是说, 不是在发布服务器上):
    1. 把这个字段添加到你的模型中.
    2. 运行 manage.py sqlall [yourapp] 会看到模型的新的 CREATE TABLE 语句.  注
        意新的字段的列定义.
    3. 启动您的数据库交互shell(也就是 psql 或 mysql ,  或者您也可以使用
        manage.py dbshell ).  执行一个ALTER TABLE 语句, 添加您的新列.
    4. (可选)用 manage.py shell 启动Python交互式shell, 并通过引入模型并选择表
        验证新的字段已被正确添加(比如, MyModel.objects.all()[:5] ).

然后在发布服务器上执行下面的步骤:
    1. 启动你的数据库的交互式命令行;
    2. 执行 ALTER TABLE 语句, 也就是在开发环境中第3步执行的语句;
    3. 添加字段到你的模型中. 如果你在开发时使用了版本控制系统并checkin了你的修
        改, 现在可以更新 代码到发布服务器上了(例如, 使用Subverison的话就是 svn
        update ).
    4. 重启Web服务器以使代码修改生效.


5.10.2 删除字段

从你的模型里删除这个字段, 并重启Web服务器.

使用如下面所示的命令, 从你的数据库中删掉该列:
ALTER TABLE books_book DROP COLUMN num_pages;


5.10.3 删除 Many-to-Many 字段

删除掉你的模型里的 ManyToManyField , 并且重启Web服务器.

使用如下面所示的命令, 删除掉你数据库里的many-to-many表:
DROP TABLE books_books_publishers;

5.10.4 删除模型

将此模型从你的 models.py 文件里删除, 并且重启Web服务器.

使用如下的命令, 将此表从你的数据库中删除:
DROP TABLE books_book;


6. Django管理站点


7. 表单处理



8. 高级视图和URL配置

8.1 流线型化(Streamlining)函数导入

8.1.1 使用"对象"指定视图函数

from django.conf.urls.defaults import *
from mysite.views import current_datetime, hours_ahead, hours_behind, now_in_chicago, now_in_london

urlpatterns = patterns('',
        (r'^now/$', current_datetime),
        (r'^now/plus(\d{1,2})hours/$', hours_ahead),
        (r'^now/minus(\d{1,2})hours/$', hours_behind),
        (r'^now/in_chicago/$', now_in_chicago),
        (r'^now/in_london/$', now_in_london),
        )


8.1.2 使用"对象"指定视图函数(改进)

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
        (r'^now/$', views.current_datetime),
        (r'^now/plus(\d{1,2})hours/$', views.hours_ahead),
        (r'^now/minus(\d{1,2})hours/$', views.hours_behind),
        (r'^now/in_chicago/$', views.now_in_chicago),
        (r'^now/in_london/$', views.now_in_london),
        )



8.1.3 使用"字符串"指定视图函数

from django.conf.urls.defaults import *

urlpatterns = patterns('',
        (r'^now/$', 'mysite.views.current_datetime'),
        (r'^now/plus(\d{1,2})hours/$', 'mysite.views.hours_ahead'),
        (r'^now/minus(\d{1,2})hours/$', 'mysite.views.hours_behind'),
        (r'^now/in_chicago/$', 'mysite.views.now_in_chicago'),
        (r'^now/in_london/$', 'mysite.views.now_in_london'),
        )


8.1.4 使用"字符串"指定视图函数(提取出一个公共视图前缀)

from django.conf.urls.defaults import *

urlpatterns = patterns('mysite.views',
        (r'^now/$', 'current_datetime'),
        (r'^now/plus(\d{1,2})hours/$', 'hours_ahead'),
        (r'^now/minus(\d{1,2})hours/$', 'hours_behind'),
        (r'^now/in_chicago/$', 'now_in_chicago'),
        (r'^now/in_london/$', 'now_in_london'),
        )


8.1.5 使用"字符串"指定视图函数(使用多个视图前缀)

from django.conf.urls.defaults import *

urlpatterns = patterns('mysite.views',
        (r'^/?$', 'archive_index'),
        (r'^(\d{4})/([a-z]{3})/$', 'archive_month'),
        )
urlpatterns += patterns('weblog.views',
        (r'^tag/(\w+)/$', 'tag'),
        )


8.1.6 调试模式中的特例

// URL /debuginfo/ 将只有在你的 DEBUG 配置项设为 True 时才有效.

from django.conf.urls.defaults import*
from django.conf import settings

urlpatterns = patterns('',
        (r'^$', 'mysite.views.homepage'),
        (r'^(\d{4})/([a-z]{3})/$', 'mysite.views.archive_month'),
        )
if settings.DEBUG:
    urlpatterns += patterns('',
            (r'^debuginfo$', 'mysite.views.debug'),
            )

8.2 使用命名组

1)  关键字参数 对比 位置参数

例如, 考虑这个简单的函数:

// 例如, 考虑这个简单的函数:
def sell(item, price, quantity):
    print "Selling %s unit(s) of %s at %s" % (quantity, item, price)

// 为了使用位置参数来调用它, 你要按照在函数定义中的顺序来指定参数.
sell('Socks', '$2.50', 6)

// 为了使用关键字参数来调用它, 你要指定参数名和值. 下面的语句是等价的:
sell(item='Socks', price='$2.50', quantity=6)
sell(item='Socks', quantity=6, price='$2.50')
sell(price='$2.50', item='Socks', quantity=6)

// 最后, 你可以混合关键字和位置参数, 只要所有的位置参数列在关键字参数之前. 下
// 面的语句与前面的例子是等价:
sell('Socks', '$2.50', quantity=6)
sell('Socks', price='$2.50', quantity=6)
sell('Socks', quantity=6, price='$2.50')


2)
在 Python 正则表达式中, 命名的正则表达式组的语法是 (?P<name>pattern) , 这里
name 是组的名字, 而 pattern 是匹配的某个模式.

// 下面是一个使用无名组的 URLconf 的例子:
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
        (r'^articles/(\d{4})/$', views.year_archive),
        (r'^articles/(\d{4})/(\d{2})/$', views.month_archive),
        )


// 下面是相同的 URLconf, 使用命名组进行了重写:
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
        (r'^articles/(?P<year>\d{4})/$', views.year_archive),
        (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/$', views.month_archive),
        )


// 例如, 如果不带命名组, 请求 /articles/2006/03/ 将会 等于这样的函数调用:
month_archive(request, '2006', '03')
// 而带命名组, 同样的请求就是这样的函数调用:
month_archive(request, year='2006', month='03')


8.3 传递额外的参数到视图函数中

一个URLconf里面的每一个模式可以包含第三个数据: 一个传到视图函数中的关键字参数
的字典.

// 这个例子中, URLconf指定了 template_name . 而视图函数则会把它处理成另一个参数而已.

# urls.py
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
        (r'^foo/$', views.foobar_view, {'template_name': 'template1.html'}),
        (r'^bar/$', views.foobar_view, {'template_name': 'template2.html'}),
        )


# views.py
from django.shortcuts import render_to_response
from mysite.models import MyModel

def foobar_view(request, template_name):
    m_list = MyModel.objects.filter(is_new=True)
    return render_to_response(template_name, {'m_list': m_list})


8.4 伪造捕捉到的URLconf值

// 例如, 你可能有一个显示某一个特定日子的某些数据的应用, URL类似这样的:
/mydata/jan/01/
/mydata/jan/02/
/mydata/jan/03/
# ...
/mydata/dec/30/
/mydata/dec/31/

// 这太简单了, 你可以在一个URLconf中捕捉这些值, 像这样(使用命名组的方法):
urlpatterns = patterns('',
        (r'^mydata/(?P<month>\w{3})/(?P<day>\d\d)/$', views.my_view),
        )

// 然后视图函数的原型看起来会是:
def my_view(request, month, day):
    # ....


问题在于当你想为添加一个使用 my_view 视图的URL但它没有包含一个month 和/或者 一
个 day .


// 比如你可能会想增加这样一个URL,  /mydata/birthday/ ,  这个URL等价于
// /mydata/jan/06/ . 这时你可以这样利用额外URLconf参数:
urlpatterns = patterns('',
        (r'^mydata/birthday/$', views.my_view, {'month': 'jan', 'day': '06'}),
        (r'^mydata/(?P<month>\w{3})/(?P<day>\d\d)/$', views.my_view),
        )



8.5 创建一个通用视图

可以创作高抽象的视图. 更具体地说, 比如这个视图显示一系列的 Event 对象, 那个视
图显示一系列的BlogEntry 对象, 并意识到它们都是一个用来显示一系列对象的视图的特
例, 而对象的类型其实就是一个变量.


// 以这段代码作为例子:

# urls.py
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
        (r'^events/$', views.event_list),
        (r'^blog/entries/$', views.entry_list),
        )


# views.py
from django.shortcuts import render_to_response
from mysite.models import Event, BlogEntry

def event_list(request):
    obj_list = Event.objects.all()
    return render_to_response('mysite/event_list.html', {'event_list': obj_list})

def entry_list(request):
    obj_list = BlogEntry.objects.all()
    return render_to_response('mysite/blogentry_list.html', {'entry_list': obj_list})


// 这两个视图做的事情实质上是一样的: 显示一系列的对象. 让我们把它们显示的对象
// 的类型抽象出来:


# urls.py
from django.conf.urls.defaults import *
from mysite import models, views

urlpatterns = patterns('',
        (r'^events/$', views.object_list, {'model': models.Event}),
        (r'^blog/entries/$', views.object_list, {'model': models.BlogEntry}),
        )

# views.py
from django.shortcuts import render_to_response

def object_list(request, model):
    obj_list = model.objects.all()
    template_name = 'mysite/%s_list.html' % model.__name__.lower()
    return render_to_response(template_name, {'object_list': obj_list})


就这样小小的改动, 我们突然发现我们有了一个可复用的, 模型无关的视图!从现在开始,
当我们需要一个视图来显示一系列的对象时, 我们可以简简单单的重用这一个
object_list 视图, 而无须另外写视图代码了.


8.6 提供视图配置选项

如果你发布一个Django的应用, 你的用户可能会希望配置上能有些自由度. 这种情况下,
为你认为用户可能希望改变的配置选项添加一些钩子到你的视图中会试一个很好的主意.
你可以用额外URLconf参数实现.

// 一个应用中比较常见的可供配置代码是模板名字:
def my_view(request, template_name):
    var = do_something()
    return render_to_response(template_name, {'var': var})


8.7 捕捉值和额外参数之间的优先级

当冲突出现的时候, 额外URLconf参数优先于捕捉值. 也就是说, 如果URLconf捕捉到的一
个命名组变量和一个额外URLconf参数包含的变量同名时, 额外URLconf参数的值会被使用


// 例如, 下面这个URLconf:
// 这里, 正则表达式和额外字典都包含了一个 id . 硬编码的(额外字典的) id 将优先
// 使用. 就是说任何请求(比如, /mydata/2/ 或者 /mydata/432432/ )都会作 id 设置
// 为 3 对待, 不管URL里面能捕捉到什么样的值.
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^mydata/(?P<id>\d+)/$', views.my_view, {'id': 3}),
        )



8.8 使用缺省视图参数

另外一个方便的特性是你可以给一个视图指定默认的参数. 这样, 当没有给这个参数赋值
的时候将会使用默认的值.

// 请看例子:

# urls.py
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^blog/$', views.page),
        (r'^blog/page(?P<num>\d+)/$', views.page),
        )

# views.py
def page(request, num="1"):
    # Output the appropriate page of blog entries, according to num.
    # ...



8.9 特殊情况下的视图

有时你有一个模式来处理在你的URLconf中的一系列URL, 但是有时候需要特别处理其中的
某个URL. 在这种情况下, 要使用将URLconf中把特殊情况放在首位的线性处理方式.

// 例如, Django的admin站点中添加一个对象页面是如下配置的:
urlpatterns = patterns('',
        ('^([^/]+)/([^/]+)/add/$', 'django.contrib.admin.views.main.add_stage'),
        )

这将匹配像 /myblog/entries/add/ 和 /auth/groups/add/ 这样的URL . 然而, 对于用
户对象的添加页面(/auth/user/add/ )是个特殊情况, 因为它不会显示所有的表单域, 它
显示两个密码域等等.

// 利用URLconf从顶向下的解析顺序这个特点:
urlpatterns = patterns('',
        ('^auth/user/add/$', 'django.contrib.admin.views.auth.user_add_stage'),
        ('^([^/]+)/([^/]+)/add/$', 'django.contrib.admin.views.main.add_stage'),
        )


8.10 从URL中捕获文本

每个被捕获的参数将被作为纯Python字符串来发送, 而不管正则表达式中的格式.

// 举个例子, 在这行URLConf中:
// 尽管 \d{4} 将只匹配整数的字符串, 但是参数 year 是作为字符串传至
// views.year_archive() 的, 而不是整型.
(r'^articles/(?P<year>\d{4})/$', views.year_archive),


8.11 决定URLconf搜索的东西

当一个请求进来时, Django试着将请求的URL作为一个普通Python字符串进行URLconf模式
匹配(而不是作为一个Unicode字符串). 这并不包括 GET 或 POST 参数或域名. 它也不包
括第一个斜杠, 因为每个URL必定有一个斜杠.

// 例如:
在向 http://www.example.com/myapp/ 的请求中,        Django将试着去匹配 myapp/ .
在向http://www.example.com/myapp/?page=3 的请求中,  Django同样会去匹配 myapp/ .

在解析URLconf时, 请求方法(例如,  POST ,  GET ,  HEAD )并 不会 被考虑. 换而言之
, 对于相同的URL的所有请求方法将被导向到相同的函数中. 因此根据请求方法来处理分
支是视图函数的责任.


8.12 包含其他URLconf

# mysite.urls
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^weblog/', include('mysite.blog.urls')),
        (r'^photos/', include('mysite.photos.urls')),
        (r'^about/$', 'mysite.views.about'),
        )

# mysite.blog.urls
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^(\d\d\d\d)/$', 'mysite.blog.views.year_detail'),
        (r'^(\d\d\d\d)/(\d\d)/$', 'mysite.blog.views.month_detail'),
        )


通过这两个URLconf, 下面是一些处理请求的例子:
    /weblog/2007/ : 在第一个URLconf中, 模式 r'^weblog/' 被匹配. 因为它是一个
                    include() , Django将截掉所有匹配的文本, 在这里是'weblog/'.
                    URL剩余的部分是 2007/ ,  将在 mysite.blog.urls 这个URLconf
                    的第一行中被匹配到.
    /weblog//2007/ :  在第一个URLconf中, 模式 r'^weblog/' 被匹配. 因为它是一个
                      include() , Django将截掉所有匹配的文本, 在这里是
                      'weblog/' . URL剩余的部分是/2007/ (开头有一个斜杠), 将不
                      会匹配mysite.blog.urls 中的任何URLconf.



8.12.1 捕获的参数如何和include()协同工作

一个被包含的URLconf接收任何来自parent URLconfs的被捕获的参数.

// 比如:
// 在这个例子中, 被捕获的 username 变量将传递给被包含的 URLconf, 进而传递给那
// 个URLconf中的 每一个 视图函数.

# root urls.py
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^(?P<username>\w+)/blog/', include('foo.urls.blog')),
        )

# foo/urls/blog.py
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^$', 'foo.views.blog_index'),
        (r'^archive/$', 'foo.views.blog_archive'),
        )


8.12.2 额外的URLconf参数如何和include()协同工作

相似的, 你可以传递额外的URLconf选项到 include() , 就像你可以通过字典传递额外的
URLconf选项到普通的视图. 当你这样做的时候, 被包含URLconf的 每一 行都会收到那些
额外的参数.

// 比如, 下面的两个URLconf在功能上是相等的.

// 第一个:

# urls.py
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^blog/', include('inner'), {'blogid': 3}),
        )

# inner.py
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^archive/$', 'mysite.views.archive'),
        (r'^about/$', 'mysite.views.about'),
        (r'^rss/$', 'mysite.views.rss'),
        )


// 第二个:

# urls.py
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^blog/', include('inner')),
        )

# inner.py
from django.conf.urls.defaults import *
urlpatterns = patterns('',
        (r'^archive/$', 'mysite.views.archive', {'blogid': 3}),
        (r'^about/$', 'mysite.views.about', {'blogid': 3}),
        (r'^rss/$', 'mysite.views.rss', {'blogid': 3}),
        )


9. 通用视图

9.1 使用通用视图

使用通用视图的方法是在URLconf文件中创建配置字典, 然后把这些字典作为URLconf元组
的第三个成员.

// 例如, 下面是一个呈现静态"关于"页面的URLconf:
// direct_to_template 视图 是通用的!
from django.conf.urls.defaults import *
from django.views.generic.simple import direct_to_template
urlpatterns = patterns('',
        ('^about/$', direct_to_template, {'template': 'about.html' })
        )



// 记住: direct_to_template 视图 是通用的!
from django.conf.urls.defaults import *
from django.views.generic.simple import direct_to_template
from mysite.books.views import about_pages
urlpatterns = patterns('',
        ('^about/$', direct_to_template, { 'template': 'about.html' }),
        ('^about/(w+)/$', about_pages),
)

from django.http import Http404
from django.template import TemplateDoesNotExist
from django.views.generic.simple import direct_to_template
def about_pages(request, page):
    try:
        # 使用通用视图: direct_to_template
        return direct_to_template(request, template="about/%s.html" % page)
    except TemplateDoesNotExist:
        raise Http404()



9.2 对象的通用视图

direct_to_template 毫无疑问是非常有用的, 但Django通用视图最有用的是在呈现 数据
库中的数据. 因为这个应用实在太普遍了, Django带有很多内建的通用视图来帮助你很容
易的生成对象的列表和明细视图.

比如: 为所有的书籍创建一个列表页面.

# urls.py
// 要为所有的书籍创建一个列表页面, 我们使用下面的URL配置:
from django.conf.urls.defaults import *
from django.views.generic import list_detail
from mysite.books.models import Publisher
publisher_info = {
    "queryset" : Publisher.objects.all(),
}
urlpatterns = patterns('',
        (r'^publishers/$', list_detail.object_list, publisher_info)
        )


注意:
    我们可以通过在额外参数 字典里包含 template_name来清楚的告诉 object_list 视
    图使用哪个模板, 但是 由于Django在不给定模板的时候会用对象的名称推导出一个.
    在这个例子中, 这个推导出的模板名称 将是 "books/publisher_list.html" , 其中
    books部分是定义这个模型的app的名称, publisher部分是这个模型名称的小写.


# books/publisher_list.html
{% extends "base.html" %}
{% block content %}
    <h2>Publishers</h2>
    <ul>
        {% for publisher in object_list %}
            <li>{{ publisher.name }}</li>
        {% endfor %}
    </ul>
{% endblock %}


9.3 扩展通用视图

9.3.1 制作友好的模板Context

我们可以很容易的象下面这样修改 template_object_name 参数的名称:

// 比如: 用象 publisher_list 这样的变量名会更好一点, 这样变量的值看起来就很清
// 楚了.
publisher_info = {
    "queryset" : Publisher.objects.all(),
    "template_object_name" : "publisher", # NEW, 最终构造出 "publisher_list"
}
urlpatterns = patterns('',
        (r'^publishers/$', list_detail.object_list, publisher_info),
        )


9.3.2 添加额外的Context

所有的通用视图都有一个额外的可选参数 extra_context . 这个参数是一个字典数据类
型, 包含要添加到模板的context中的额外的对象.

# urls.py
// 这样就把一个 {{ book_list }} 变量放到模板的context中. 这个方法可以用来传递
// 任意数据 到通用视图模板中去, 非常方便.
publisher_info = {
    "queryset" : Publisher.objects.all(),
    "template_object_name" : "publisher",
    "extra_context" : {"book_list" : Book.objects.all()}
}


注意:   这里有一个很隐蔽的BUG:
    我们现在来看一下,  extra_context 里包含数据库查询的问题. 因为在这个例子中,
    我们把 Publisher.objects.all()放在URLconf中, 它只会执行一次(当URLconf第一
    次加载的时候). 当你添加或删除出版商, 你会发现在重启Web服务器之前, 通用视图
    不会反映出这些修改的.


Solution:
    解决这个问题的办法是在 extra_context 中用一个回调(callback)来 代替使用一个
    变量. 任何可以调用的对象(例如一个函数)在传递给 extra_context 后都会在每次
    视图渲染前执行(而不是只执行一次).

    // 注意 Book.objects.all 后面没有括号; 这表示这是一个函数的引用, 并没有 真
    // 调用它(通用视图将会在渲染时调用它).
    publisher_info = {
        "queryset" : Publisher.objects.all(),
        "template_object_name" : "publisher",
        # 注意 Book.objects.all 后面没有括号; 这表示这是一个函数的引用, 并没有
        # 真调用它(通用视图将会在渲染时调用它).
        "extra_context" : {"book_list" : Book.objects.all}
    }


9.3.3 显示对象的子集(queryset)

大多数通用视图有一个 queryset 参数, 这个参数告诉视图要显示对象的集合.

// 举一个简单的例子, 我们打算对书籍列表按出版日期排序, 最近的排在最前:
book_info = {
    "queryset" : Book.objects.all().order_by("-publication_date"),
}
urlpatterns = patterns('',
        (r'^publishers/$', list_detail.object_list, publisher_info),
        (r'^books/$', list_detail.object_list, book_info),
        )


9.3.4 用函数包装来处理复杂的数据过滤

通过对 object_list 通用视图进行包装.

# urls.py
urlpatterns = patterns('',
        (r'^publishers/$', list_detail.object_list, publisher_info),
        (r'^books/(\w+)/$', books_by_publisher),
        )

# books_by_publisher 视图:
from django.http import Http404
from django.views.generic import list_detail
from mysite.books.models import Book, Publisher
def books_by_publisher(request, name):
    # Look up the publisher (and raise a 404 if it can't be found).
    try:
        publisher = Publisher.objects.get(name__iexact=name)
    except Publisher.DoesNotExist:
        raise Http404
    # Use the object_list view for the heavy lifting.
    return list_detail.object_list(
            request,
            queryset = Book.objects.filter(publisher=publisher),
            template_name = "books/books_by_publisher.html",
            template_object_name = "books",
            extra_context = {"publisher" : publisher}
            )


9.4 处理额外工作

我们再来看看最后一个常用模式: 在调用通用视图前后做些额外工作.

想象一下我们在 Author 对象里有一个 last_accessed 字段, 我们用这个字段来更正
对author的最近访问时间. 当然通用视图 object_detail 并不能处理 这个问题, 我
们可以很容易的写一个自定义的视图来更新这个字段.

// 首先, 我们需要在URL配置里设置指向到新的自定义视图:
from mysite.books.views import author_detail
urlpatterns = patterns('',
        (r'^authors/(?P<author_id>\d+)/$', author_detail),
        )

// 接下来写包装函数:
import datetime
from mysite.books.models import Author
from django.views.generic import list_detail
from django.shortcuts import get_object_or_404
def author_detail(request, author_id):
    author = get_object_or_404(Author, pk=author_id)
    author.last_accessed = datetime.datetime.now() # NOTE
    author.save() # NOTE
    return list_detail.object_detail(
            request,
            queryset = Author.objects.all(),
            object_id = author_id,
            )

// books/author_detail.html
...










a

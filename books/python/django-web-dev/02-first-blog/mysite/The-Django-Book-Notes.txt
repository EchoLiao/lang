

在你视图的任何位置, 临时插入一个 assert False 来触发出错页. 然后, 你就可以看到
局部变量和程序语句了.



4.  Django模板系统

4.1 启动交互界面

// 启动交互界面
$ python manage.py shell


// 下面是一些基本操作:
>>> from django.template import Template
>>> t = Template("My name is {{ name }}.")
>>> print t


// 如果你的模板语法有错误, 那么在调用 Template() 时就会抛出
// TemplateSyntaxError 异常:
>>> from django.template import Template
>>> t = Template('{% notatag %} ')
Traceback (most recent call last):
File "<stdin>", line 1, in ?
...
django.template.TemplateSyntaxError: Invalid block tag: 'notatag'


4.2 调用 Template 对象的 render() 方法并传递context来填充模板:

// 调用 Template 对象的 render() 方法并传递context来填充模板:
>>> from django.template import Context, Template
>>> t = Template("My name is {{ name }}.")
>>> c = Context({"name": "Stephane"})
>>> t.render(c)
'My name is Stephane.'


4.3 字典和Contexts

// 字典和Contexts
// 下面是编写模板并渲染的示例:
>>> from django.template import Template, Context
>>> raw_template = """<p>Dear {{ person_name }},</p>
... <p>Thanks for ordering {{ product }} from {{ company }}. It's scheduled
... to ship on {{ ship_date|date:"F j, Y" }}.</p>
... {% if ordered_warranty %}
... <p>Your warranty information will be included in the packaging.</p>
... {% endif %}
... <p>Sincerely,<br />{{ company }}</p>"""
>>> t = Template(raw_template)
>>> import datetime
>>> c = Context({'person_name': 'John Smith',
... 'product': 'Super Lawn Mower',
... 'company': 'Outdoor Equipment',
... 'ship_date': datetime.date(2009, 4, 2),
... 'ordered_warranty': True})
>>> t.render(c)
"<p>Dear John Smith,</p>\n\n<p>Thanks for ordering Super Lawn Mower from
Outdoor Equipment. It's scheduled \nto ship on April 2, 2009.</p>\n\n\n
<p>Your warranty information will be included in the packaging.</p>\n\n\n
<p>Sincerely,<br />Outdoor Equipment</p>"
>>> print t.render(c)


# 这就是使用Django模板系统的基本规则: 写模板, 创建 Template 对象, 创建
# Context ,  调用 render() 方法.


4.4 同一模板 多个上下文

// 同一模板, 多个上下文
// 一旦有了 模板 对象, 你就可以通过它渲染多个背景(context), 例如:
>>> from django.template import Template, Context
>>> t = Template('Hello, {{ name }}')
>>> print t.render(Context({'name': 'John'}))
Hello, John
>>> print t.render(Context({'name': 'Julie'}))
Hello, Julie
>>> print t.render(Context({'name': 'Pat'}))
Hello, Pat


// 无论何时像这样使用同一模板源渲染多个背景, 只创建 一次 模板 对象, 然后对它多
// 次调用 render() 将会更加高效.
# Bad
>>> for name in ('John', 'Julie', 'Pat'):
>>>     t = Template('Hello, {{ name }}')
>>>     print t.render(Context({'name': name}))
>>>
# Good
>>> t = Template('Hello, {{ name }}')
>>> for name in ('John', 'Julie', 'Pat'):
>>>     print t.render(Context({'name': name}))
>>>


4.5 使用句点可以访问字典的键值 属性 索引 对象的方法

// 在 Django 模板中遍历复杂数据结构的关键是句点字符 (.). 使用句点可以访问字典
// 的键值,属性,索引和对象的方法.
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
'Sally is 43 years old.'


// 同样, 也可以通过句点来访问对象的属性. 比方说,  Python 的 datetime.date 对象
// 有 year , month 和 day 几个属性,
>>> from django.template import Template, Context
>>> import datetime
>>> d = datetime.date(1993, 5, 2)
>>> d.year
1993
>>> d.month
5
>>> d.day
2
>>> t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')
>>> c = Context({'date': d})
>>> t.render(c)
'The month is 5 and the year is 1993.'


4.5.1 用了一个自定义类:

// 下例使用了一个自定义类:
>>> from django.template import Template, Context
>>> class Person(object):
...     def __init__(self, first_name, last_name):
...         self.first_name, self.last_name = first_name, last_name
...
>>> t = Template('Hello, {{ person.first_name }} {{ person.last_name }}.')
>>> c = Context({'person': Person('John', 'Smith')})
>>> t.render(c)
'Hello, John Smith.'


4.5.2 句点还用于调用对象的方法

// 句点还用于调用对象的方法. 例如, 每个 Python 字符串都有 upper() 和 isdigit()
// 方法, 你在模板中可以使用同样的句点语法来调用它们:
// 注意: 你不能在方法调用中使用圆括号. 而且也无法给该方法传递参数; 你只能调用
//       不需参数的方法.
>>> from django.template import Template, Context
>>> t = Template('{{ var }} -- {{ var.upper }} -- {{ var.isdigit }}')
>>> t.render(Context({'var': 'hello'}))
'hello -- HELLO -- False'
>>> t.render(Context({'var': '123'}))
'123 -- 123 -- True'


4.5.3 句点也可用于访问列表索引

// 句点也可用于访问列表索引, 例如:
// 注意: 不允许使用负数列表索引. 像 {{ items.-1 }} 这样的模板变量将会引发
//       TemplateSyntaxError 异常.
>>> from django.template import Template, Context
>>> t = Template('Item 2 is {{ items.2 }}.')
>>> c = Context({'items': ['apples', 'bananas', 'carrots']})
>>> t.render(c)
'Item 2 is carrots.'


4.5.4 句点查找规则可概括为:

# 句点查找规则可概括为: 当模板系统在变量名中遇到点时,按照以下顺序尝试进行查找:
#   字典类型查找 (比如 foo["bar"] )
#   属性查找 (比如 foo.bar )
#   方法调用 (比如 foo.bar() )
#   列表类型索引查找 (比如 foo[bar] )
# 系统使用所找到的第一个有效类型. 这是一种短路逻辑.


4.5.5 句点查找可以多级深度嵌套

// 句点查找可以多级深度嵌套
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name.upper }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
'SALLY is 43 years old.'

4.5.6 方法调用行为

# 方法调用行为
// 方法调用比其他类型的查找略为复杂一点. 以下是一些注意事项:
// 在方法查找过程中, 如果某方法抛出一个异常, 除非该异常有一个
// silent_variable_failure属性并且值为 True , 否则的话它将被传播. 如果该异常
// 确有属性 silent_variable_failure , 那么(所查找)变量将被渲染为空字符串,
// 例如:
>>> t = Template("My name is {{ person.first_name }}.")
>>> class PersonClass3:
...     def first_name(self):
...         raise AssertionError, "foo"
...
>>> p = PersonClass3()
>>> t.render(Context({"person": p}))
Traceback (most recent call last):
...
AssertionError: foo

>>> class SilentAssertionError(AssertionError):
...     silent_variable_failure = True
...
>>> class PersonClass4:
...     def first_name(self):
...         raise SilentAssertionError
...
>>> p = PersonClass4()
>>> t.render(Context({"person": p}))
"My name is ."


// 不允许模板包含像 {{account.delete}} 这样的方法调用, 必须设置该方法的
// alters_data 函数属性:
// 模板系统不会执行任何以该方式进行标记的方法. 也就是说, 如果模板包含了
// {{account.delete}} ,该标签不会调用 delete() 方法. 它只会安静地失败(并不会
// 引发异常).
def delete(self):
    # Delete the account
    delete.alters_data = True


4.5.7 如何处理无效变量

# 如何处理无效变量
// 默认情况下, 如果一个变量不存在, 模板系统会把它展示为空字符串, 不做任何事情
// 地表示失败, 例如:
>>> from django.template import Template, Context
>>> t = Template('Your name is {{ name }}.')
>>> t.render(Context())
'Your name is .'
>>> t.render(Context({'var': 'hello'}))
'Your name is .'
>>> t.render(Context({'NAME': 'hello'}))
'Your name is .'
>>> t.render(Context({'Name': 'hello'}))
'Your name is .'


4.6 玩一玩上下文(context)对象

// 多数时间, 你可以通过传递一个完全填充(full populated)的字典给 Context() 来初
// 始化 上下文(Context) .  但是初始化以后, 你也可以从``上下文(Context)`` 对象
// 添加或者删除条目, 使用标准的Python字典语法(syntax):
>>> from django.template import Context
>>> c = Context({"foo": "bar"})
>>> c['foo']
'bar'
>>> del c['foo']
>>> c['foo']
''
>>> c['newvariable'] = 'hello'
>>> c['newvariable']
'hello'


4.7 标签

4.7.1 if/else

// {% else %} 标签是可选的:
{% if today_is_weekend %}
    <p>Welcome to the weekend!</p>
{% else %}
    <p>Get back to work.</p>
{% endif %}

4.7.1.1 Python 的"真值"

在python中空的列表 ( [] ), tuple( () ), 字典( {} ), 字符串( '' ), 零( 0 ), 还
有 None 对象, 在逻辑判断中都为假, 其他的情况都为真.

4.7.1.2 {% if %} 标签接受 and or 或者 not 关键字来对多个变量做判断 或者对变量取反( not )

{% if athlete_list and coach_list %}
    Both athletes and coaches are available.
{% endif %}
{% if not athlete_list %}
    There are no athletes.
{% endif %}
{% if athlete_list or coach_list %}
    There are some athletes or some coaches.
{% endif %}
{% if not athlete_list or coach_list %}
    There are no athletes or there are some coaches. (OK, so
    writing English translations of Boolean logic sounds
    stupid; it's not our fault.)
{% endif %}
{% if athlete_list and not coach_list %}
    There are some athletes and absolutely no coaches.
{% endif %}


4.7.1.3 {% if %} 标签不允许在同一个标签中同时使用 and 和 or

{% if %} 标签不允许在同一个标签中同时使用 and 和 or , 因为逻辑上可能模糊的, 例如, 如下示例是错误的:
{% if athlete_list and coach_list or cheerleader_list %} // 错误!!!!!


// 系统不支持用圆括号来组合比较操作. 如果你发现需要组合操作, 可以使用嵌套的
// {% if %} 标签
{% if athlete_list %}
    {% if coach_list or cheerleader_list %}
        We have athletes, and either coaches or cheerleaders!
    {% endif %}
{% endif %}

// 多次使用同一个逻辑操作符是没有问题的
{% if athlete_list or coach_list or parent_list or teacher_list %}

// 并没有 {% elif %} 标签, 请使用嵌套的 {% if %} 标签来达成同样的效果:
{% if athlete_list %}
    <p>Here are the athletes: {{ athlete_list }}.</p>
{% else %}
    <p>No athletes are available.</p>
    {% if coach_list %}
        <p>Here are the coaches: {{ coach_list }}.</p>
    {% endif %}
{% endif %}


4.7.2 for

// 例如, 给定一个运动员列表 athlete_list 变量, 我们可以使用下面的代码来显示这个列表:
<ul>
{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
{% endfor %}
</ul>

// 给标签增加一个 reversed 使得该列表被反向迭代:
{% for athlete in athlete_list reversed %}
    ...
{% endfor %}

// 可以嵌套使用 {% for %} 标签:
{% for country in countries %}
    <h1>{{ country.name }}</h1>
    <ul>
        {% for city in country.city_list %}
            <li>{{ city }}</li>
        {% endfor %}
    </ul>
{% endfor %}

4.7.2.1 {% for %} 标签在循环中的一个特殊的 forloop 模板变量

{% for %} 标签在循环中设置了一个特殊的 forloop 模板变量. 这个变量能提供一些当
前循环进展的信息:

1)  forloop.counter 总是一个表示当前循环的执行次数的整数计数器.
    这个计数器是从1开始的, 所以在第一次循环时 forloop.counter 将会被设置为1.

// 例子如下:
{% for item in todo_list %}
    <p>{{ forloop.counter }}: {{ item }}</p>
{% endfor %}

2)  forloop.counter0 类似于 forloop.counter , 但是它是从0计数的.
    第一次执行循环时这个变量会被设置为0.

3)  forloop.revcounter 是表示循环中剩余项的整型变量.
    在循环初次执行时 forloop.revcounter 将被设置为序列中项的总数. 最后一次循环
    执行中, 这个变量将被置1.

4)  forloop.revcounter0 类似于 forloop.revcounter , 但它以0做为结束索引.
    在第一次执行循环时, 该变量会被置为序列的项的个数减1. 在最后一次迭代时, 该
    变量为0.

5)  forloop.first 是一个布尔值. 在第一次执行循环时该变量为True, 在下面的情形中
    这个变量是很有用的.

{% for object in objects %}
    {% if forloop.first %}<li class="first">{% else %}<li>{% endif %}
    {{ object }}
    </li>
{% endfor %}

6)  forloop.last 是一个布尔值; 在最后一次执行循环时被置为True.
    一个常见的用法是在一系列的链接之间放置管道符(|)

{% for link in links %}{{ link }}{% if not forloop.last %} | {% endif %}{% endfor %}
    The above template code might output something like this::
    Link1 | Link2 | Link3 | Link4

7)  forloop.parentloop 是一个指向当前循环的上一级循环的 forloop 对象的引用(在嵌
    套循环的情况下).

// 例子在此:
{% for country in countries %}
    <table>
    {% for city in country.city_list %}
        <tr>
        <td>Country #{{ forloop.parentloop.counter }}</td>
        <td>City #{{ forloop.counter }}</td>
        <td>{{ city }}</td>
        </tr>
    {% endfor %}
    </table>
{% endfor %}


4.7.3 ifequal/ifnotequal

{% ifequal %} 标签比较两个值, 当他们相同时, 显示在 {% ifequal %} 和
{% endifequal %} 之中所有的值.

// 下面的例子比较两个模板变量 user 和 currentuser :
{% ifequal user currentuser %}
    <h1>Welcome!</h1>
{% endifequal %}

// 参数可以是硬编码的字符串, 随便用单引号或这双引号引起来, 所以下列代码都是正
// 确的:
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% endifequal %}
{% ifequal section "community" %}
    <h1>Community</h1>
{% endifequal %}

// 和 {% if %} 类似,  {% ifequal %} 支持可选的 {% else%} 标签:
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% else %}
    <h1>No News Here</h1>
{% endifequal %}

// 注意:    只有模板变量, 字符串, 整数和小数可以作为 {% ifequal %} 标签的参数.
//          其他的一些类型, 例如Python的字典类型,列表类型,布尔类型, 不能用在
//          {% ifequal %} 中.
//这些是正确的例子:
{% ifequal variable 1 %}
{% ifequal variable 1.23 %}
{% ifequal variable 'foo' %}
{% ifequal variable "foo" %}


4.8 注释

象HTML和其他的语言例如python一样, Django模板系统也允许注释.  注释使用 {# #} :

注释不能跨多行.

{# This is a comment #}


4.9 过滤器

1)  使用 | 来应用过滤器.

2)  过滤器可以被 串联 ,就是说一个过滤器的输出可以被输入到下一个过滤器.

// 这里有一个常用的 需求, 先转义文本到HTML, 再转换每行到 <p> 标签:
{{ my_text|escape|linebreaks }}

3)  过滤器参数总是使用双引号标识.

// 这个将显示变量 bio 的前30个词.
{{ bio|truncatewords:"30" }}


4.9.1 一些最重要的过滤器

1)  addslashes : 添加反斜杠到任何反斜杠,单引号或者双引号前面.
    这在处理包含JavaScript的文本时是非常有用的.

2)  date : 按指定的格式字符串参数格式化 date 或者 datetime 对象.

// 范例:
{{ pub_date|date:"F j, Y" }}

3)  escape : 转义 &符号, 引号, <, > 符号.

这在确保用户提交的数据是有效的XML或XHTML时是非常有用的.

具体上,  escape 做下面这些转换:
    转换 & 到 &amp;
    转换 < 到 &lt;
    转换 > 到 &gt;
    转换 " (双引号) 到 &quot;
    转换 ' (单引号) 到 &#39;

4)  length : 返回变量的长度.

你可以对列表或者字符串, 或者任何知道怎么测定长度的Python 对象使用这个方法(也就
是说, 有 __len__() 方法的对象).





5. 和数据库打交道: 数据建模

5.1 数据库配置

象前面章节提到的 TEMPLATE_DIRS 一样, 数据库配置也是在Django的配置文件里, 缺省
是 settings.py . 编辑打开这个文件并查找数据库配置:

DATABASE_ENGINE = ''
DATABASE_NAME = ''
DATABASE_USER = ''
DATABASE_PASSWORD = ''
DATABASE_HOST = ''
DATABASE_PORT = ''


DATABASE_ENGINE     告诉Django使用哪个数据库引擎. 如果你在 Django 中使用数据库,
DATABASE_ENGINE     必须是 Table 5-1 中所列出的值.
    表 5-1. 数据库引擎设置
    ...
DATABASE_NAME       将数据库名称告知 Django . 如果使用 SQLite, 请对数据库文件
                    指定完整的文件系统路径. (例如 '/home/django/mydata.db' ).
DATABASE_USER       告诉 Django 用哪个用户连接数据库. 如果用SQLite, 空白即可.
DATABASE_PASSWORD   告诉Django连接用户的密码. SQLite 用空密码即可.
DATABASE_HOST       告诉 Django 连接哪一台主机的数据库服务器. 如果数据库与
                    Django 安装于同一台计算机(即本机), 可将此项保留空白. 使用
                    SQLite , 也可保留空白.
                    此处的 MySQL 是一个特例. 如果使用的是 MySQL 且该项设置值由
                    斜杠( '/' )开头, MySQL 将通过 Unix socket 来连接指定的套接
                    字, 例如:
                        DATABASE_HOST = '/var/run/mysql'
                    如果用 MySQL 而该项设置的值 不是 以正斜线开始的, 系统将假
                    定该项值是主机名.
DATABASE_PORT       告诉 Django 连接数据库时使用哪个端口. 如果用SQLite, 空白即
                    可. 其他情况下, 如果将该项设置保留空白, 底层数据库适配器将
                    会连接所给定数据库服务器的缺省端口.


// 启动交互界面
$ python manage.py shell

// 输入下面这些命令来测试你的数据库配置:
>>> from django.db import connection
>>> cursor = connection.cursor()


5.2 你的第一个应用程序

须创建一个新的app.

// 转到 mysite 项目目录, 执行下面的命令来创建一个新app叫做books:
$ python manage.py startapp books


// 第一步是用Python代码来描述它们. 打开 models.py 并输入下面的内容:
from django.db import models

class Publisher(models.Model):
    name = models.CharField(maxlength=30)
    address = models.CharField(maxlength=50)
    city = models.CharField(maxlength=60)
    state_province = models.CharField(maxlength=30)
    country = models.CharField(maxlength=50)
    website = models.URLField()

class Author(models.Model):
    salutation = models.CharField(maxlength=10)
    first_name = models.CharField(maxlength=30)
    last_name = models.CharField(maxlength=40)
    email = models.EmailField()
    headshot = models.ImageField(upload_to='/tmp')

class Book(models.Model):
    title = models.CharField(maxlength=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()


编辑 settings.py 文件,  找到 INSTALLED_APPS 设置.  INSTALLED_APPS 告诉 Django
项目哪些 app 处于激活状态.


// 现在我们可以创建数据库表了. 首先, 用下面的命令对校验模型的有效性:
$ python manage.py validate


// 模型确认没问题了, 运行下面的命令来生成 CREATE TABLE 语句:
$ python manage.py sqlall books


// 执行这些SQL语句. 运行 syncdb 命令:
$ python manage.py syncdb


注意:   syncdb 并 不能 同步模型的修改到数据库. 如果你修改了模型, 然后你想更新 数
        据库, 是帮不了你的.


// 登录进数据库服务器看看刚才Django创建的数据表.  Django带有一个命令行工具,
$ python manage.py dbshell


5.3 基本数据访问

运行 python manage.py shell 并输入下面的内容试试看:

$ python manage.py shell

>>> from books.models import Publisher
>>> p1 = Publisher(name='Addison-Wesley', address='75 Arlington Street',
...  city='Boston', state_province='MA', country='U.S.A.',
...  website='http://www.apress.com/')
...
>>> p1.save()
>>> p2 = Publisher(name="O'Reilly", address='10 Fawcett St.',
...  city='Cambridge', state_province='MA', country='U.S.A.',
...  website='http://www.oreilly.com/')
...
>>> p2.save()
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Publisher object>, <Publisher: Publisher object>]


添加模块的字符串表现


>>> from books.models import Publisher
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Addison-Wesley>, <Publisher: O'Reilly>]


5.4 插入和更新数据

// 先使用一些关键参数创建对象实例, 如下:
>>> p = Publisher(name='Apress',
...  address='2755 Telegraph Ave.',
...  city='Berkeley',
...  state_province='CA',
...  country='U.S.A.',
...  website='http://www.apress.com/')
...
>>> p.save()

>>> p.id
 52  // this will differ based on your own data

// 接下来再调用 save() 将不会创建新的记录, 而只是修改记录内容(也就是 执行
// UPDATE SQL语句, 而不是 INSERT 语句):
>>> p.name = 'Apress Publishing'
>>> p.save()


5.5 选择对象

// 查找所有数据的方法:
>>> Publisher.objects.all()
[<Publisher: Addison-Wesley>, <Publisher: O'Reilly>, <Publisher: Apress Publishing>]


5.6 数据过滤

// 如果想要获得数据的一个子集, 我们可以使用 filter() 方法:
>>> Publisher.objects.filter(name="Apress Publishing")
[<Publisher: Apress Publishing>]

    filter() 根据关键字参数来转换成 WHERE SQL语句. 前面这个例子 相当于这样:
    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name = 'Apress Publishing';


// 可以传递多个参数到 filter() 来缩小选取范围:
>>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
[<Publisher: Apress Publishing>]

>>> Publisher.objects.filter(name__contains="press")
[<Publisher: Apress Publishing>]


5.7 获取单个对象

// 有时你只想获取单个对象, 这个时候使用 get() 方法:
>>> Publisher.objects.get(name="Apress Publishing")
<Publisher: Apress Publishing>

这样, 就返回了单个对象, 而不是列表(更准确的说, QuerySet).
所以, 如果结果是多个对象, 会导致抛出异常, 如果查询没有返回结果也会抛出异常.


5.8 数据排序

用 order_by() 来 排列返回的数据:

>>> Publisher.objects.order_by("name")
[<Publisher: Apress Publishing>, <Publisher: Addison-Wesley>, <Publisher: O'Reilly>]

>>> Publisher.objects.order_by("state_provice", "address")
[<Publisher: Apress Publishing>, <Publisher: O'Reilly>, <Publisher: Addison-Wesley>]

// 我们还可以指定逆向排序, 在前面加一个减号 - 前缀:
>>> Publisher.objects.order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

// 同时做 过滤和排序
>>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

// 只显示第一个. 你可以 这样做:
>>> Publisher.objects.all()[0]
<Publisher: Addison-Wesley>


5.9 删除对象

// 要删除对象, 只需简单的调用对象的 delete() 方法:
>>> p = Publisher.objects.get(name="Addison-Wesley")
>>> p.delete()
>>> Publisher.objects.all()
[<Publisher: Apress Publishing>, <Publisher: O'Reilly>]

// 还可以批量删除对象, 通过对查询的结果调用 delete() 方法:
>>> publishers = Publisher.objects.all()
>>> publishers.delete()
>>> Publisher.objects.all()
[]

注意:
    删除是 不可恢复 的, 所以要小心操作!事实上, 应该尽量避免删除对象, 除非你 确
    实需要删除它. 数据库的数据恢复的功能通常不太好, 而从备份数据恢复是很痛苦的


5.10 修改数据库表结构

当我们在这一章的前面介绍 syncdb 命令的时候, 我们强调 syncdb 仅仅创建数据库中不
存在的表, 而不会同步模型的修改或者删除到数据库. 如果你添加或者修改了模型的一个
字段, 或者删除一个模型, 你必须手动改变你的数据库.


当我们处理表结构的修改时, 要时刻想着 Django 的数据库层是如何工作的:
    1)  如果模型中包含一个在数据库中并不存在的字段, Django会大声抱怨的. 这样当你第
        一次调用Django的数据库API来查询给定的表时就会出错(也就是说, 它会在执行的时
        候出错, 而不是编译的时候)
    2)  Django并不关心数据库表中是否存在没有在模型中定义的列
    3)  Django并不关心数据库中是否包含没有模型描述的表


5.10.1 添加字段

首先, 在开发环境中执行下面的步骤(也就是说, 不是在发布服务器上):
    1. 把这个字段添加到你的模型中.
    2. 运行 manage.py sqlall [yourapp] 会看到模型的新的 CREATE TABLE 语句.  注
        意新的字段的列定义.
    3. 启动您的数据库交互shell(也就是 psql 或 mysql ,  或者您也可以使用
        manage.py dbshell ).  执行一个ALTER TABLE 语句, 添加您的新列.
    4. (可选)用 manage.py shell 启动Python交互式shell, 并通过引入模型并选择表
        验证新的字段已被正确添加(比如, MyModel.objects.all()[:5] ).

然后在发布服务器上执行下面的步骤:
    1. 启动你的数据库的交互式命令行;
    2. 执行 ALTER TABLE 语句, 也就是在开发环境中第3步执行的语句;
    3. 添加字段到你的模型中. 如果你在开发时使用了版本控制系统并checkin了你的修
        改, 现在可以更新 代码到发布服务器上了(例如, 使用Subverison的话就是 svn
        update ).
    4. 重启Web服务器以使代码修改生效.


5.10.2 删除字段

从你的模型里删除这个字段, 并重启Web服务器.

使用如下面所示的命令, 从你的数据库中删掉该列:
ALTER TABLE books_book DROP COLUMN num_pages;


5.10.3 删除 Many-to-Many 字段

删除掉你的模型里的 ManyToManyField , 并且重启Web服务器.

使用如下面所示的命令, 删除掉你数据库里的many-to-many表:
DROP TABLE books_books_publishers;

5.10.4 删除模型

将此模型从你的 models.py 文件里删除, 并且重启Web服务器.

使用如下的命令, 将此表从你的数据库中删除:
DROP TABLE books_book;


6. Django管理站点


7. 表单处理







































a
